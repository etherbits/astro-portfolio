---
import type { HTMLAttributes } from "astro/types";
import { waveObjs } from "../waves";
import { cn } from "../utils/tailwind";

type WaveKey = keyof typeof waveObjs;

interface Props extends HTMLAttributes<"svg"> {
  type: WaveKey;
  delay?: number;
}

const { delay = 0, ...props } = Astro.props;

const { viewBox, lines } = waveObjs[props.type];
---

<svg
  viewBox={viewBox}
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
  preserveAspectRatio="none"
  class={cn(
    "fixed pointer-events-none overflow-hidden stroke-slate-700 stroke-[2px]",
    props.class,
  )}
  svg-waves
  {...props}
>
  {lines.map((line) => <path d={line.d} bg-lines />)}
  {
    lines.map((line) => {
      return <path d={line.d} fg-lines />;
    })
  }
</svg>

<script>
  import anime from "animejs/lib/anime.es";
  const svgWaves = document.querySelectorAll("[svg-waves]");

  function attachLineAnimations() {
    svgWaves.forEach((wave, i) => {
      const bgLines = wave.querySelectorAll("[bg-lines]");
      const fgLines = wave.querySelectorAll(
        "[fg-lines]",
      ) as NodeListOf<SVGPathElement>;
      anime({
        targets: bgLines,
        strokeDashoffset: [anime.setDashoffset, 0],
        opacity: (_: SVGPathElement, j: number) => [0.1, (j + 1) / 10],
        easing: "easeInOutSine",
        duration: 2000,
        delay: function (_, i) {
          return i * 150;
        },
        loop: false,
      });

      anime({
        targets: fgLines,
        strokeDashoffset: (el: SVGPathElement) => {
          return [anime.setDashoffset, -el.getTotalLength()];
        },
        easing: "linear",
        stroke: ["#60a5fa", "#3b82f6", "#2563eb"],
        opacity: (_: any, j: number) => [
          1 - (fgLines.length - (j + 1)) / fgLines.length,
          0,
          0,
        ],
        duration: 2000,
        delay: (_, j) => {
          return 2000 + j * 150;
        },
        loop: true,
      });
    });
  }

  attachLineAnimations();
</script>
